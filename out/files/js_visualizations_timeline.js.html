<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>js/visualizations/timeline.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: js/visualizations/timeline.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
function TimeLine(options) {
    options = options || {};

    function my() {
        my.init(options);

        /*
         * Fonction qui est appelee lors d&#x27;un resize de l&#x27;ecran
         */
        function resize() {
            if (parseInt(d3.select(&quot;#graph&quot;).style(&quot;height&quot;)) &lt; 200) {
                my.brushHeight(0);
            }
            else if (parseInt(d3.select(&quot;#graph&quot;).style(&quot;height&quot;)) &lt; 400) {
                my.brushHeight(30);
            }
            else {
                my.brushHeight(50);
            }

            // On redefinit les tailles
            var width = parseInt(d3.select(&quot;#graph&quot;).style(&quot;width&quot;)) - my.margin() * 2,
                    height = parseInt(d3.select(&quot;#graph&quot;).style(&quot;height&quot;)) - my.brushHeight() - options.brush.marginTop - my.margin() * 2;

            // Modification de la hauteur et de la largeur
            my.resize(height, width);

            // Redessine le graphe de maniere reponsive
            my.redraw();
        }

        // Add resize event
        $$ResponsiveUtil.addResizeEvent(resize);
    }

    my.init = function (options) {
    	my.isMobile($$ResponsiveUtil.mobile());
        //On cree un nouveau noeud &lt;svg&gt;
        my.margin(options.margin || 60);
        my.svg(d3.select(&quot;body&quot;).append(&quot;svg&quot;).attr(&quot;id&quot;, &quot;graph&quot;)
        		.attr(&quot;class&quot;, &quot;timeline&quot;)
                .attr(&quot;width&quot;, window.innerWidth)
                .attr(&quot;height&quot;, window.innerHeight));
        my.svg().append(&quot;defs&quot;).append(&quot;clipPath&quot;)
                .attr(&quot;id&quot;, &quot;clip&quot;)
                .append(&quot;rect&quot;)
                .attr(&quot;width&quot;, window.innerWidth - (2 * my.margin()))
                .attr(&quot;height&quot;, window.innerHeight);

        // Initialisation de la taille du graphe
        my.width(options.width || parseInt(d3.select(&quot;#graph&quot;).style(&quot;width&quot;)) - my.margin() * 2);
        my.height(options.height || parseInt(d3.select(&quot;#graph&quot;).style(&quot;height&quot;)) - my.margin() * 2);

        // Initialisation des donnees
        my.initData(options.data, options.formatDate);

        // Initialisation du brush
        my.initBrush(options.brush || {});

        // Initialisation du graphe
        my.initGraph(my.margin(), my.height(), my.width(), my.data());

        // Initialisation du rectangle
        my.initRect(my.svg(), my.width(), my.height(), my.margin());

        /*
         * On recupere la premiere et derniere
         * valeur pour les afficher avec un cercle
         * si la visualisation est trop petite
         */
        if (options.firstEndCircle) {
            my.updateFirstEndCircle(my.graph(), my.firstRecord(), my.lastRecord());
        }

        // On met les evenements sur le graphe a jour
        my.updateMove(my.rect(), &quot;mousemove&quot;, &quot;mouseout&quot;, true);
        my.updateMove(my.rect(), &quot;touchmove&quot;, &quot;touchend&quot;, false);

        // Resize du graph
        my.resize(my.height(), my.width());

        // Redessine le graphe de maniere reponsive
        my.redraw();

        return my;
    };

    /*******************************
     * Fonctions d&#x27;initialisation
     ********************************/

    /*
     * Initialisation des donnees
     */
    my.initData = function (pData, formatDate) {
        var data = pData || [];
        var parseDate = formatDate != null ? d3.time.format(formatDate).parse : d3.time.format(&quot;%Y-%m&quot;).parse;
        data.forEach(function (d) {
            d.date = parseDate(d.date);
            d.close = +d.close;
        });
        my.data(data);
        my.firstRecord(data[0]);
        my.lastRecord(data[data.length - 1]);
    };

    /*
     * Initialisation du graphe
     */
    my.initGraph = function (margin, height, width, data) {
        var graph = d3.select(&quot;#graph&quot;)
                .append(&quot;g&quot;)
                .attr(&quot;height&quot;, my.height())
                .attr(&quot;width&quot;, my.width())
                .attr(&quot;class&quot;, &quot;focus&quot;);

        if (margin) {
            graph.attr(&quot;transform&quot;, &quot;translate(&quot; + margin + &quot;,&quot; + margin + &quot;)&quot;);
        }

        // Initialisation du tooltip
        my.tooltip(new ResponsiveTooltip({
        	g : graph,
        	cls: &quot;fixed_tooltip&quot;
        })());
        
        // Initialisation des axes
        // Axes des x
        my.x(new ResponsiveAxis({
            g: graph,
            orientation: $$ResponsiveUtil._BOTTOM_,
            datatype: &quot;year&quot;,
            cls: &quot;x axis&quot;,
            domain: d3.extent(data, function (d) {
                return d.date;
            }),
            autosize: false
        })());
        // Axes des y
        my.y(new ResponsiveAxis({
            g: graph,
            orientation: $$ResponsiveUtil._LEFT_,
            cls: &quot;y axis&quot;,
            domain: [0, d3.max(data, function (d) {
                    return d.close;
                })],
            autosize: false
        })());
        
        /*
         * On definit la visualisation principale
         */

        // Definition un zone
        var area = d3.svg.area()
                .interpolate(&quot;monotone&quot;)
                .x(function (d) {
                    return my.x()(d.date);
                })
                .y0(my.height())
                .y1(function (d) {
                    return my.y()(d.close);
                });
        my.area(area);

        var dataPerPixel = data.length / width;
        var dataResampled = data.filter(function (d, i) {
            return i % Math.ceil(dataPerPixel) === 0;
        });

        graph.append(&quot;path&quot;)
                .datum(dataResampled)
                .attr(&quot;class&quot;, &quot;area&quot;)
                .attr(&quot;d&quot;, area);
        
        graph.append(&quot;circle&quot;)
	        .attr(&quot;class&quot;, &quot;y&quot;)
	        .style(&quot;fill&quot;, &quot;none&quot;)
	        .style(&quot;stroke&quot;, &quot;blue&quot;)
	        .style(&quot;opacity&quot;, 0)
	        .attr(&quot;r&quot;, 4);
	        

        my.graph(graph);
    };

    /*
     * Initialisation du rectangle qui aura
     * les evenements mousemove et touchmove
     */
    my.initRect = function (container, width, height, margin) {
        // On cree un rectangle par dessus la visualisation
        var rect = container.append(&quot;rect&quot;)
                .attr(&quot;width&quot;, width - margin)
                .attr(&quot;height&quot;, height)
                .attr(&quot;transform&quot;, &quot;translate(&quot; + margin + &quot;,&quot; + margin + &quot;)&quot;)
                .style(&quot;opacity&quot;, 0)
                .attr(&quot;class&quot;, &quot;onMouseMove&quot;);
        my.rect(rect);
    };

    /*
     * Initialisation du brush
     */
    my.initBrush = function (brushOpts) {
        my.initContext(brushOpts);
    };

    /*
     * Initialisation du context qui aura
     * la visualisation plus petite
     */
    my.initContext = function (brushOpts) {
    	// Height
        my.brushHeight(brushOpts.height);
        // Revu de la taille du graph original
        my.height(my.height() - my.brushHeight() - my.margin());
        var context = my.svg().append(&quot;g&quot;)
        		.attr(&quot;height&quot;, my.brushHeight())
                .attr(&quot;width&quot;, my.width())
                .attr(&quot;class&quot;, &quot;context&quot;)
                .attr(&quot;transform&quot;, &quot;translate(&quot; + my.margin() + &quot;,&quot; + (my.height() + my.margin() + options.brush.marginTop) + &quot;)&quot;);
        
        if (!brushOpts) {
            return;
        }
        
        // Axes des x
        my.brushX(new ResponsiveAxis({
            g: context,
            orientation: $$ResponsiveUtil._BOTTOM_,
            datatype: &quot;year&quot;,
            cls: &quot;x axis&quot;,
            domain: d3.extent(data, function (d) {
                return d.date;
            }),
            autosize: false
        })());
        // Axes des y
        my.brushY(new ResponsiveAxis({
            g: context,
            orientation: $$ResponsiveUtil._LEFT_,
            cls: &quot;y axis&quot;,
            domain: [0, d3.max(data, function (d) {
                    return d.close;
                })],
            autosize: false
        })());

        // Definition du brush 
        var brush = d3.svg.brush()
                .x(my.brushX())
                .on(&quot;brush&quot;,
                        function () {
                            my.brushed();
                        }
                );
        my.brush(brush);
        
     // Definition un zone
        var area = d3.svg.area()
                .interpolate(&quot;monotone&quot;)
                .x(function (d) {
                    return my.brushX()(d.date);
                })
                .y0(my.brushHeight())
                .y1(function (d) {
                    return my.brushY()(d.close);
                });
        my.brushArea(area);

        var dataPerPixel = data.length / width;
        var dataResampled = data.filter(function (d, i) {
            return i % Math.ceil(dataPerPixel) === 0;
        });

        context.append(&quot;path&quot;)
                .datum(dataResampled)
                .attr(&quot;class&quot;, &quot;area&quot;)
                .attr(&quot;d&quot;, area);
        
//        context.append(&quot;g&quot;)
//                .attr(&quot;class&quot;, &quot;x axis&quot;)
//                .attr(&quot;transform&quot;, &quot;translate(0,&quot; + my.brushHeight() + &quot;)&quot;)
//                .call(my.brushXAxis());

//        context.append(&quot;g&quot;)
//                .attr(&quot;class&quot;, &quot;x brush&quot;)
//                .call(my.brush())
//                .selectAll(&quot;rect&quot;)
//                .attr(&quot;y&quot;, -6)
//                .attr(&quot;height&quot;, my.brushHeight() + 7);

        my.context(context);
    };

    /************************
     * Getters AND Setters
     ************************/

    my.isMobile = function (newIsMobile) {
		if (!arguments.length) {
			return isMobile;
		}
		isMobile = newIsMobile;
		return my;
	};
	
    my.svg = function (newSvg) {
        if (!arguments.length) {
            return svg;
        }
        svg = newSvg;
        return my;
    };
    
    my.tooltip = function (newTooltip) {
        if (!arguments.length) {
            return tooltip;
        }
        tooltip = newTooltip;
        return my;
    };
    
    my.x = function (newX) {
        if (!arguments.length) {
            return x;
        }
        x = newX;
        return my;
    };

    my.y = function (newY) {
        if (!arguments.length) {
            return y;
        }
        y = newY;
        return my;
    };

    my.graph = function (newGraph) {
        if (!arguments.length) {
            return graph;
        }
        graph = newGraph;
        return my;
    };

    my.data = function (newData) {
        if (!arguments.length) {
            return data;
        }
        data = newData;
        return my;
    };

    my.width = function (newWidth) {
        if (!arguments.length) {
            return width;
        }
        width = newWidth;
        return my;
    };

    my.height = function (newHeight) {
        if (!arguments.length) {
            return height;
        }
        height = newHeight;
        return my;
    };

    my.margin = function (newMargin) {
        if (!arguments.length) {
            return margin;
        }
        margin = newMargin;
        return my;
    };

    my.lastRecord = function (newLastRecord) {
        if (!arguments.length) {
            return lastRecord;
        }
        lastRecord = newLastRecord;
        return my;
    };

    my.firstRecord = function (newFirstRecord) {
        if (!arguments.length) {
            return firstRecord;
        }
        firstRecord = newFirstRecord;
        return my;
    };

    my.rect = function (newRect) {
        if (!arguments.length) {
            return rect;
        }
        rect = newRect;
        return my;
    };

    my.updateArgsRect = function (width, height, margin) {
        if (!arguments.length) {
            return my.rect();
        }
        my.rect()
                .attr(&quot;width&quot;, width)
                .attr(&quot;height&quot;, height);

        return my.rect();
    };

    my.area = function (newArea) {
        if (!arguments.length) {
            return area;
        }
        area = newArea;
        return my;
    };

    /*
     * Setters et Getters du Brush
     */

    my.brush = function (newBrush) {
        if (!arguments.length) {
            return brush;
        }
        brush = newBrush;
        return my;
    };

    my.brushHeight = function (newBrushHeight) {
        if (!arguments.length) {
            return brushHeight;
        }
        brushHeight = newBrushHeight;
        return my;
    };

    my.brushX = function (newBrushX) {
        if (!arguments.length) {
            return brushX;
        }
        brushX = newBrushX;
        return my;
    };

    my.brushY = function (newBrushY) {
        if (!arguments.length) {
            return brushY;
        }
        brushY = newBrushY;
        return my;
    };

    my.brushXAxis = function (newBrushXAxis) {
        if (!arguments.length) {
            return brushXAxis;
        }
        brushXAxis = newBrushXAxis;
        return my;
    };

    my.brushYAxis = function (newBrushYAxis) {
        if (!arguments.length) {
            return brushYAxis;
        }
        brushYAxis = newBrushYAxis;
        return my;
    };

    my.focus = function (newFocus) {
        if (!arguments.length) {
            return focus;
        }
        focus = newFocus;
        return my;
    };

    my.context = function (newContext) {
        if (!arguments.length) {
            return context;
        }
        context = newContext;
        return my;
    };

    my.brushArea = function (newBrushArea) {
        if (!arguments.length) {
            return brushArea;
        }
        brushArea = newBrushArea;
        return my;
    };

    /************************
     * Methods
     ************************/
    
    /*
     * Cette methode applique les redimensions
     * de la visualisation
     */
    my.resize = function (height, width) {
        if (arguments.length) {
            my.height(height);
            my.width(width);
        }

        // On met a jour les axes et le svg
        my.svg().attr(&quot;width&quot;, my.width());
        if(my.height() &gt; 0){
            my.svg().attr(&quot;height&quot;, my.height());
        }

        // On met a jour le rectangle qui a les evenement mousemove
        // et touchmove
        my.updateArgsRect(my.width(), my.height(), my.margin());
        return my;
    };

    /*
     * Cette methode redessine le graphe
     */
    my.redraw = function () {
        my.svg().select(&quot;rect&quot;)
                .attr(&quot;width&quot;, window.innerWidth - (2 * my.margin()))
                .attr(&quot;height&quot;, window.innerHeight);

        var dataPerPixel = my.data().length / my.width();
        var dataResampled = my.data().filter(function (d, i) {
            return i % Math.ceil(dataPerPixel) === 0;
        });

        my.area().y0(my.height());
        my.graph().select(&#x27;.area&#x27;).datum(dataResampled).attr(&quot;d&quot;, my.area());

        // Resize du brush
//        my.brushX().range([0, my.width()]);
//        my.brushY().range([my.brushHeight(), 0]);
//        my.brushXAxis().ticks(Math.max(my.width() / 100, 2));
//        my.context().attr(&quot;transform&quot;, &quot;translate(&quot; + my.margin() + &quot;,&quot; + (my.height() + my.margin() + options.brush.marginTop) + &quot;)&quot;);
//        my.context().select(&#x27;.x.axis&#x27;)
//                .attr(&quot;transform&quot;, &quot;translate(0,&quot; + my.brushHeight() + &quot;)&quot;)
//                .call(my.brushXAxis());
        my.brushArea().y0(my.brushHeight());
        my.context().select(&#x27;.area&#x27;).datum(dataResampled).attr(&quot;d&quot;, my.brushArea());
    };

    /*
     * Cette methode met a jour les cercles 
     * de la premiere et derniere valeur
     */
    my.updateFirstEndCircle = function (graph, firstRecord, lastRecord) {
        var first = graph.append(&quot;g&quot;)
                .attr(&quot;class&quot;, &quot;first&quot;)
                .style(&quot;display&quot;, &quot;none&quot;);

        first.append(&quot;text&quot;)
                .attr(&quot;x&quot;, -8)
                .attr(&quot;y&quot;, 4)
                .attr(&quot;text-anchor&quot;, &quot;end&quot;)
                .text(firstRecord.close);
        first.append(&quot;circle&quot;).attr(&quot;r&quot;, 4);

        var last = graph.append(&quot;g&quot;)
                .attr(&quot;class&quot;, &quot;last&quot;)
                .style(&quot;display&quot;, &quot;none&quot;);

        last.append(&quot;text&quot;)
                .attr(&quot;x&quot;, 8)
                .attr(&quot;y&quot;, 4)
                .text(lastRecord.close);
        last.append(&quot;circle&quot;)
                .attr(&quot;r&quot;, 4);
    };
    
    /*
     * Cette methode affiche une etiquette
     * associe au bloc clique et met des numeros 
     * dans les cellules pour les associer aux
     * etiquettes
     */
	my.drawTooltip = function(data, pathinfo){
		//var pathinfo = my.pathinfo();
        var html = &quot;&lt;ol&gt;&quot;;
        var i = 1;
        var name = &quot;&quot;;
        for(key in data){
            html += &quot;&lt;li&gt;&quot;;
            html += key;
            html += &quot;: &quot;;
            html += data[key];
            html += &quot;&lt;/li&gt;&quot;;
            i++;
        }
        html += &quot;&lt;/ol&gt;&quot;;
        
        my.tooltip().trigger(&quot;redraw&quot;, html);
	}

    /*
     * Cette methode applique les etiquettes
     * lorsqu&#x27;on se deplace sur la courbe
     */
    my.updateMove = function (container, event, eventEnd, onDesktop) {
    	var width = my.width();
    	var height = my.height();
    	var margin = my.margin();
    	var formatter = d3.time.format(&quot;%d/%m/%Y&quot;);
    	var bisectDate = d3.bisector(function(d) { return d.date; }).left;
    	container.on(event, function () {
    		// Recuperation de la position X &amp; Y
    		var cursor;
    		var cursor_x;
    		if (onDesktop) {
    			cursor = d3.mouse(this);
    			cursor_x = d3.mouse(this)[0];
    		}
    		else {
    			cursor = d3.touches(this)[0];
    		}
    		var cursor_x = parseInt(cursor[0]);
    		var cursor_y = parseInt(cursor[1]);
    		
    		var x0 = x.invert(d3.mouse(this)[0]),
    		i = bisectDate(my.data(), x0, 1),
    		d0 = my.data()[i - 1],
    		d1 = my.data()[i],
    		d = x0 - d0.date &gt; d1.date - x0 ? d1 : d0;
    		    		
    		my.graph().select(&quot;circle.y&quot;)
    		.style(&quot;opacity&quot;, 1)
    		.attr(&quot;transform&quot;,
    				&quot;translate(&quot; + x(d.date) + &quot;,&quot; +
    				y(d.close) + &quot;)&quot;);

    		// On affiche l&#x27;etiquette associee
    		var data = {
    				Date: formatter(d.date),
    				Valeur: d.close
    		}
    		var pathinfo = [
    		                {
    		                	x: x(d.date) - 50,
    		                	y: y(d.close)
    		                },
    		                {
    		                	x: x(d.date) + 50,
    		                	y: y(d.close)
    		                }
    		                ];
    		my.drawTooltip(data, pathinfo);
        })
        .on(eventEnd, function () {
            if (onDesktop) {
                var cursor = d3.mouse(this);
                var cursor_x = parseInt(cursor[0]);
                var cursor_y = parseInt(cursor[1]);
                // Si la position de la souris est en dehors de la zone du graphique, 
                // on masque la ligne et le tooltip
                if (cursor_x &lt; margin || cursor_x &gt; (width + margin) || cursor_y &lt; margin || cursor_y &gt; (height + margin)) {
                   
                	my.tooltip().trigger(&quot;hide&quot;);
                    
                	d3.select(&quot;circle&quot;).style(&quot;opacity&quot;, 0);
                }
            }
            else {
            	my.tooltip().trigger(&quot;hide&quot;);
            	
                d3.select(&quot;circle&quot;).style(&quot;opacity&quot;, 0);
            }
        });
    };

    /*
     * Methods du Brush
     */
    my.brushed = function () {
        my.x().domain(my.brush().empty() ? my.brushX().domain() : my.brush().extent());
        my.graph().select(&quot;.area&quot;).attr(&quot;d&quot;, my.area());
        my.graph().select(&quot;.x.axis&quot;).call(my.xAxis());
    };

    return my;

}
;
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
